class Solution {
public:
 vector<vector<int>> ans;
void backtrack(vector<int>& candidates, int target,int start,vector<int>&curr){
    // in this question we have to use backtracking and the concept of recursion

    if(target == 0){// means if our target become zero we leave the backtracking
    ans.push_back(curr);
    return ;

    }

    for(int i  = start; i<candidates.size();i++){
        if(i>start && candidates[i] == candidates[i-1])continue;//skip the duplicates


        if(candidates[i] > target)break;

        curr.push_back(candidates[i]);

        backtrack(candidates,target-candidates[i],i+1,curr);

          curr.pop_back();
    }
}
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(),candidates.end());
        

        vector<int> curr;
        backtrack(candidates,target,0,curr);
        return ans;
    }
};
