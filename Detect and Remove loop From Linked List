we will do with two methd first one take minimum time complexity which is bit complex but highly recommended

Node *removeLoop(Node *head) {
    if (!head || !head->next) return head;

    Node *slow = head, *fast = head;

    // Step 1: Detect loop
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) break; // loop found
    }

    // No loop
    if (slow != fast) return head;

    // Step 2: Find start of loop
    slow = head;
    if (slow == fast) {
        // Case: loop starts at head
        while (fast->next != slow) fast = fast->next;
    } else {
        while (slow->next != fast->next) {
            slow = slow->next;
            fast = fast->next;
        }
    }

    // Step 3: Remove loop
    fast->next = NULL;

    return head;
}



Now we will do the second method in which we have simpler but hae higher time complexity



Problem statement
Given a singly linked list, you have to detect the loop and remove the loop from the linked list, if present. You have to make changes in the given linked list itself and return the updated linked list.

Expected Complexity: Try doing it in O(n) time complexity and O(1) space complexity. Here, n is the number of nodes in the linked list.

Detailed explanation ( Input/output format, Notes, Images )
Constraints:
1 <= N <= 100000.
1 <= ‘VAL’ <= 1000 .  

Time limit: 1 sec
Sample Input:
6 2
1 2 3 4 5 6 
Sample Output:
1 2 3 4 5 6


/*************************************************
    
    class Node {
        public :

        int data;
        Node *next;

        Node(int data) {
            this -> data = data;
            this -> next = NULL;
        }
    };

*************************************************/
#include<map>
Node * prev(Node * head){
    if(head == NULL) return NULL;
    map<Node* , bool> visited;

    Node * temp = head;

    while(temp != NULL){

        if(visited[temp->next] == true){
                return temp;
        }

        visited[temp] = true;

        temp = temp->next;
    }

    return NULL;
}
Node *removeLoop(Node *head)
{
    // Write your code here.

    Node * prevnode = prev(head);

    prevnode->next = NULL;

    return head;
    



}

